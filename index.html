<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Anonymous Feedback ‚úçÔ∏è</title>
  <style>
    /* ====== General Page Styling ====== */
    :root {
      --bg-color: #121212;
      --surface-color: #1e1e1e;
      --primary-color: #4da3ff;
      --primary-hover: #007bff;
      --text-primary: #e0e0e0;
      --text-secondary: #aaa;
      --border-color: #333;
      --admin-color: #ffd700;
      --tuntun-color: #ff4136;
      --mention-bg: #2a2a2a;
      --reaction-highlight: rgba(77, 163, 255, 0.2); /* For user's own reaction */
    }

    body {
      font-family: Arial, sans-serif;
      background-color: var(--bg-color);
      color: var(--text-primary);
      line-height: 1.6;
      padding: 20px;
    }

    .container {
      max-width: 700px;
      margin: 0 auto;
      background-color: var(--surface-color);
      padding: 25px;
      border-radius: 8px;
      box-shadow: 0 0 15px rgba(255, 255, 255, 0.1);
      display: none; /* Hidden by default */
    }

    h1, h2 {
      text-align: center;
      color: var(--primary-color);
    }
    
    h2 {
      border-bottom: 2px solid var(--border-color);
      padding-bottom: 10px;
    }

    p {
      text-align: center;
      color: var(--text-secondary);
    }
    
    .comment-text, .reply-text {
      text-align: left !important;
    }

    .warning-text {
      color: #ffcc00;
      font-size: 0.9em;
      text-align: center;
      margin: 10px 0;
    }

    hr {
      border: none;
      border-top: 1px solid var(--border-color);
      margin: 20px 0;
    }

    /* ====== Login/Register Screen ====== */
    .auth-container {
      max-width: 400px;
      margin: 40px auto;
      background-color: var(--surface-color);
      padding: 30px;
      border-radius: 8px;
      box-shadow: 0 0 15px rgba(255, 255, 255, 0.1);
      display: none; /* Hidden by default */
    }

    .auth-container h2 {
      margin-bottom: 20px;
    }

    .auth-container input {
      width: 100%;
      box-sizing: border-box;
      padding: 10px;
      margin-bottom: 15px;
      border: 1px solid #444;
      border-radius: 4px;
      background-color: #222;
      color: var(--text-primary);
    }

    .auth-container button {
      width: 100%;
      background-color: var(--primary-hover);
      color: #fff;
      border: none;
      border-radius: 4px;
      padding: 12px;
      font-size: 16px;
      cursor: pointer;
      transition: background-color 0.3s ease;
    }

    .auth-container button:hover {
      background-color: #0056b3;
    }

    .auth-container .toggle-form {
      text-align: center;
      margin-top: 15px;
      color: var(--primary-color);
      cursor: pointer;
      font-size: 0.9em;
    }
    
    .auth-error {
      color: var(--tuntun-color);
      text-align: center;
      margin-bottom: 10px;
      font-size: 0.9em;
      min-height: 1.2em;
    }

    /* ====== Header / User Status ====== */
    .header-controls {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }
    
    #authStatus {
      font-size: 0.9em;
      color: var(--text-secondary);
    }

    #logoutBtn {
      background: none;
      border: 1px solid var(--tuntun-color);
      color: var(--tuntun-color);
      padding: 5px 10px;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.3s;
    }
    
    #logoutBtn:hover {
      background: var(--tuntun-color);
      color: #fff;
    }

    /* ====== Tabs Styling ====== */
    .tabs-container {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
      border-bottom: 2px solid var(--border-color);
      flex-wrap: wrap;
    }

    .tab-btn {
      padding: 10px 15px;
      cursor: pointer;
      background-color: transparent;
      border: none;
      color: var(--text-secondary);
      font-size: 16px;
      font-weight: bold;
      border-bottom: 3px solid transparent;
      transition: all 0.3s ease;
    }

    .tab-btn:hover {
      color: var(--text-primary);
    }

    .tab-btn.active {
      color: var(--primary-color);
      border-bottom-color: var(--primary-color);
    }

    /* ====== Comment Form ====== */
    #commentForm textarea {
      width: 100%;
      box-sizing: border-box;
      padding: 10px;
      border: 1px solid #444;
      border-radius: 4px;
      resize: vertical;
      min-height: 80px;
      margin-bottom: 10px;
      background-color: #222;
      color: var(--text-primary);
    }

    #commentForm button {
      width: 100%;
      background-color: var(--primary-hover);
      color: #fff;
      border: none;
      border-radius: 4px;
      padding: 10px;
      font-size: 16px;
      cursor: pointer;
      transition: background-color 0.3s ease;
    }

    #commentForm button:hover {
      background-color: #0056b3;
    }
    
    #commentForm:disabled, #commentForm button:disabled {
      cursor: not-allowed;
      opacity: 0.7;
    }
    
    /* ====== Sort & Filter ====== */
    .sort-container {
      display: flex;
      justify-content: flex-end;
      align-items: center;
      margin: 15px 0 5px 0;
      gap: 10px;
    }
    
    .sort-container label {
      font-size: 0.9em;
      color: var(--text-secondary);
    }
    
    .sort-container select {
      background-color: #222;
      color: var(--text-primary);
      border: 1px solid #444;
      border-radius: 4px;
      padding: 5px;
    }

    /* ====== Comments & Replies ====== */
    .comment-box,
    .reply-box {
      position: relative;
      border: 2px solid var(--primary-color);
      padding: 12px 12px 15px 12px;
      border-radius: 6px;
      margin-top: 12px;
      background-color: #181818;
    }

    .reply-box {
      margin-left: 20px; /* Indent replies */
      border-color: #555;
    }
    
    .pinned-comment {
      border-color: var(--admin-color);
      border-width: 2px;
      box-shadow: 0 0 8px var(--admin-color);
    }
    
    .pinned-badge {
      font-size: 0.8em;
      font-weight: bold;
      color: var(--admin-color);
      margin-left: 10px;
    }

    .comment-header {
      display: flex;
      align-items: center;
      margin-bottom: 8px;
      position: relative; /* For menu positioning */
    }
    
    .comment-author {
      font-weight: bold;
      font-size: 0.95em;
      color: var(--text-primary);
    }
    
    .comment-author.admin {
      color: var(--admin-color);
    }
    
    .comment-author.tuntun {
      color: var(--tuntun-color);
    }
    
    .comment-time {
      font-size: 0.8em;
      color: var(--text-secondary);
      margin-left: 8px;
    }

    .comment-box p,
    .reply-box p {
      margin: 0 0 8px 0;
      font-size: 15px;
      color: #f5f5f5;
      white-space: pre-wrap;
      word-break: break-word;
    }
    
    /* Mention highlighting */
    .mention {
      background-color: var(--mention-bg);
      color: var(--primary-color);
      font-weight: bold;
      border-radius: 3px;
      padding: 1px 4px;
    }
    
    /* ====== Comment Menu (New) ====== */
    .comment-menu {
      position: absolute;
      top: -5px;
      right: -5px;
    }
    
    .menu-trigger-btn {
      background: none;
      border: none;
      color: var(--text-secondary);
      font-size: 24px;
      cursor: pointer;
      padding: 5px;
      line-height: 1;
    }
    
    .menu-trigger-btn:hover {
      color: var(--text-primary);
    }
    
    .menu-dropdown {
      display: none;
      position: absolute;
      right: 0;
      top: 30px;
      background-color: var(--surface-color);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
      z-index: 10;
      width: 120px;
    }
    
    .menu-dropdown button {
      display: block;
      width: 100%;
      text-align: left;
      background: none;
      border: none;
      color: var(--text-primary);
      padding: 8px 12px;
      font-size: 14px;
      cursor: pointer;
    }
    
    .menu-dropdown button:hover {
      background-color: #333;
    }
    
    .menu-dropdown .delete-btn,
    .menu-dropdown .delete-btn.confirm {
      color: var(--tuntun-color);
    }
    
    .menu-dropdown .pin-btn {
      color: var(--admin-color);
    }


    /* ====== Reaction and Reply Controls ====== */
    .controls {
      display: flex;
      flex-wrap: wrap; /* Mobile friendly */
      align-items: center;
      justify-content: space-between;
      margin-top: 10px;
      gap: 10px; /* Space between groups */
    }
    
    .action-buttons {
      display: flex;
      align-items: center;
      gap: 10px; /* Space between buttons */
    }

    .reaction-options {
      display: flex;
      gap: 6px;
      flex-wrap: wrap; /* Mobile friendly */
      justify-content: flex-end;
    }

    .reaction {
      cursor: pointer;
      font-size: 18px;
      transition: all 0.2s;
      user-select: none;
      padding: 2px 4px; /* Added padding */
      border-radius: 4px; /* Added border-radius */
      border: 1px solid transparent; /* Placeholder for highlight */
    }

    .reaction:hover {
      transform: scale(1.25);
    }
    
    /* NEW: Style for user's own reaction */
    .reaction.user-reacted {
      background-color: var(--reaction-highlight);
      border-color: var(--primary-color);
    }

    .reply-btn {
      background: none;
      border: none;
      cursor: pointer;
      font-size: 14px;
      color: var(--primary-color);
      transition: color 0.3s;
      padding: 0;
    }

    .reply-btn:hover {
      color: #1e90ff;
    }

    .replies {
      margin-top: 10px;
      margin-left: 20px;
    }

    .reply-form, .edit-form {
      margin-top: 10px;
      background-color: #202020;
      border: 1px solid var(--border-color);
      border-radius: 6px;
      padding: 10px;
    }
    
    .reply-form textarea, .edit-form textarea {
      width: 100%;
      box-sizing: border-box;
      border: 1px solid #555;
      border-radius: 4px;
      resize: vertical;
      min-height: 60px;
      padding: 6px;
      background-color: #2a2a2a;
      color: var(--text-primary);
    }
    
    .reply-form .mention-suggestions {
      margin-top: 8px;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }
    
    .reply-form .mention-suggestions span {
      font-size: 0.9em;
      color: var(--text-secondary);
    }
    
    .reply-form .mention-btn {
      background: var(--mention-bg);
      color: var(--primary-color);
      border: none;
      padding: 3px 6px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.9em;
    }

    .reply-form-buttons, .edit-form-buttons {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
      margin-top: 6px;
    }

    .reply-form button, .edit-form button {
      background-color: var(--primary-hover);
      color: white;
      border: none;
      padding: 6px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      transition: background-color 0.3s ease;
    }
    
    .reply-form button.cancel-btn, .edit-form button.cancel-btn {
      background-color: #555;
    }

    .reply-form button:hover, .edit-form button:hover {
      background-color: #0056b3;
    }
    
    .reply-form button.cancel-btn:hover, .edit-form button.cancel-btn:hover {
      background-color: #777;
    }

    #commentsContainer p {
      text-align: center;
      color: var(--text-secondary);
      font-style: italic;
      margin-top: 20px;
    }
    
    /* ====== Notifications ====== */
    #notificationBell {
      font-size: 24px;
      cursor: pointer;
      position: relative;
    }
    
    #notificationDot {
      position: absolute;
      top: 0;
      right: 0;
      width: 10px;
      height: 10px;
      background-color: var(--tuntun-color);
      border-radius: 50%;
      display: none; /* Hidden by default */
    }

    #notificationPanel {
      display: none;
      position: absolute;
      right: 20px;
      top: 60px;
      width: 320px; /* Slightly wider */
      max-height: 400px;
      overflow-y: auto;
      background-color: var(--surface-color);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
      z-index: 100;
    }
    
    #notificationList {
      list-style: none;
      padding: 0;
      margin: 0;
    }
    
    #notificationList li {
      padding: 12px;
      border-bottom: 1px solid var(--border-color);
      font-size: 0.9em;
      color: var(--text-secondary);
      cursor: pointer; /* Clickable */
      transition: background-color 0.2s;
    }
    
    #notificationList li:hover {
      background-color: #2a2a2a;
    }
    
    #notificationList li:last-child {
      border-bottom: none;
    }
    
    #notificationList li strong {
      color: var(--text-primary);
    }
    
    /* NEW: Notification time */
    #notificationList .notification-time {
      display: block;
      font-size: 0.9em;
      color: var(--text-secondary);
      margin-top: 4px;
    }

    #notificationList .no-notifications {
      text-align: center;
      padding: 20px;
      font-style: italic;
      cursor: default;
    }
    #notificationList .no-notifications:hover {
      background-color: transparent;
    }

    /* ====== "What's New" Modal ====== */
    #whatsNewModal {
      display: none; /* Hidden by default */
      position: fixed;
      z-index: 1001;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7);
      align-items: center;
      justify-content: center;
    }

    .modal-content {
      background-color: var(--surface-color);
      margin: 15% auto;
      padding: 25px;
      border: 1px solid var(--border-color);
      border-radius: 8px;
      width: 90%;
      max-width: 500px;
      box-shadow: 0 5px 20px rgba(0, 0, 0, 0.5);
    }

    .modal-content h2 {
      color: var(--primary-color);
      margin-top: 0;
    }

    .modal-content ul {
      list-style: '‚ú®';
      padding-left: 20px;
    }
    
    .modal-content li {
      margin-bottom: 10px;
    }

    .modal-content button {
      background-color: var(--primary-hover);
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 16px;
      float: right;
      transition: background-color 0.3s ease;
    }
    
    .modal-content button:hover {
      background-color: #0056b3;
    }
    
    /* ====== NEW: Notification Post Modal ====== */
    #postModal {
      display: none; /* Hidden by default */
      position: fixed;
      z-index: 1002; /* Above "What's New" */
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7);
      align-items: center;
      justify-content: center;
    }
    
    #postModal .modal-content {
      width: 90%;
      max-width: 700px;
      max-height: 80vh;
      overflow-y: auto;
      padding-top: 40px; /* Space for close button */
    }
    
    #postModal .modal-content h2 {
      margin-top: 0;
    }
    
    #postModalClose {
      position: absolute;
      top: 15px;
      right: 25px;
      color: var(--text-secondary);
      font-size: 30px;
      font-weight: bold;
      cursor: pointer;
    }
    
    #postModalClose:hover {
      color: var(--text-primary);
    }
    
    #postModalBody {
      /* The comment-box will be injected here */
    }
  </style>
</head>

<body>

  <!-- "What's New" Modal -->
  <div id="whatsNewModal">
    <div class="modal-content">
      <h2>What's New!</h2>
      <p>This site has been upgraded with new features:</p>
      <ul>
        <li><b>Accounts:</b> Create a unique anonymous username/password to log in.</li>
        <li><b>Notifications:</b> Get in-app notifications (üîî) for replies and reactions.</li>
        <li><b>Edit & Delete:</b> You can now edit or delete your own comments and replies.</li>
        <li><b>Mentions:</b> Use `@username` to mention and notify other users.</li>
        <li><b>Admin Tools:</b> Admins can now pin and delete posts.</li>
      </ul>
      <button id="closeModalBtn">Got it!</button>
    </div>
  </div>
  
  <!-- NEW: Notification Post Modal -->
  <div id="postModal">
    <div class="modal-content">
      <span id="postModalClose">&times;</span>
      <h2>Notification</h2>
      <div id="postModalBody">
        <!-- Comment will be injected here -->
      </div>
    </div>
  </div>

  <!-- Login/Register Screen -->
  <div id="authContainer" class="auth-container">
    <div id="loginForm">
      <h2>Login</h2>
      <p class="warning-text">Warning: For anonymity, do not use a personal username. Create a new, unique one for this site.</p>
      <div id="loginError" class="auth-error"></div>
      <input type="text" id="loginUsername" placeholder="Username" required>
      <input type="password" id="loginPassword" placeholder="Password" required>
      <button id="loginBtn">Login</button>
      <div class="toggle-form" id="showRegister">Don't have an account? Register</div>
    </div>
    
    <div id="registerForm" style="display: none;">
      <h2>Register</h2>
      <p class="warning-text">Warning: For anonymity, do not use a personal username. Create a new, unique one for this site.</p>
      <div id="registerError" class="auth-error"></div>
      <input type="text" id="registerUsername" placeholder="Username" required>
      <input type="password" id="registerPassword" placeholder="Password" required>
      <button id="registerBtn">Register</button>
      <div class="toggle-form" id="showLogin">Already have an account? Login</div>
    </div>
  </div>

  <!-- Main App Container -->
  <div class="container" id="appContainer">
    <div class="header-controls">
      <div id="authStatus">Loading...</div>
      <div id="notificationBell">
        <span>üîî</span>
        <div id="notificationDot"></div>
      </div>
      <button id="logoutBtn">Logout</button>
    </div>
    
    <!-- Notification Panel -->
    <div id="notificationPanel">
      <ul id="notificationList">
        <li class="no-notifications">No new notifications.</li>
      </ul>
    </div>

    <h1>Anonymous Feedback ‚úçÔ∏è</h1>
    <p>Share your thoughts about ISRT.</p>

    <div id="tabsContainer" class="tabs-container">
      <button class="tab-btn active" data-category="general">General</button>
      <button class="tab-btn" data-category="seniors">Seniors</button>
      <button class="tab-btn" data-category="juniors">Juniors</button>
      <button class="tab-btn" data-category="faculty">Faculty</button>
      <button class="tab-btn" data-category="all">All Comments</button>
    </div>

    <form id="commentForm">
      <textarea id="commentText" placeholder="Your anonymous comment here..." required disabled></textarea>
      <p class="warning-text">Warning: Do not share any personal details. All comments are anonymous.</p>
      <button type="submit" id="commentSubmitBtn" disabled>Submit Comment</button>
    </form>

    <hr />
    <h2>Previous Comments</h2>
    <p style="font-size: 0.9em; color: #ccc;">Previous Comments (before categories) are stored in "all comments" section.</p>

    <div class="sort-container">
      <label for="sortOrder">Sort by: </label>
      <select id="sortOrder">
        <option value="newest">Newest</option>
        <option value="popular">Most Reacted</option>
      </select>
    </div>

    <div id="loading" style="text-align: center; margin: 20px 0;">Loading comments...</div>
    <div id="commentsContainer"><p>No comments yet. Be the first!</p></div>
  </div>

  <script type="module">
    // Firebase Imports
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import {
      getAuth,
      onAuthStateChanged,
      createUserWithEmailAndPassword,
      signInWithEmailAndPassword,
      signOut,
    } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import {
      getDatabase,
      ref,
      push,
      onValue,
      update,
      set,
      remove,
      off,
      onChildAdded,
      onChildRemoved,
      query,
      limitToLast,
      get 
    } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-database.js";

    // Firebase Config
    const firebaseConfig = {
      apiKey: "AIzaSyBi0DtNzX0niHbV4LtId7PaxLoD8Pphy6U",
      authDomain: "comment-on-isrt-8a634.firebaseapp.com",
      databaseURL: "https://comment-on-isrt-8a634-default-rtdb.asia-southeast1.firebasedatabase.app",
      projectId: "comment-on-isrt-8a634",
      storageBucket: "comment-on-isrt-8a634.appspot.com",
      messagingSenderId: "173989173917",
      appId: "1:173989173917:web:613693b2c98c4c121e9274",
    };

    // Initialize Firebase
    const app = initializeApp(firebaseConfig);
    const db = getDatabase(app);
    const auth = getAuth(app);

    // Global State
    let currentCategory = 'general';
    let authUser = null; // { uid, username }
    const reactions = ["üëç", "üòÇ", "üòç", "üò¢", "üòÆ", "üò°", "üòÄ"];
    const FAKE_EMAIL_DOMAIN = "@isrt-feedback.com";
    let allUsers = {}; // Cache for @mentions { uid: 'username' }
    let currentSortOrder = 'newest';
    let activeNotificationListeners = []; // To detach listeners
    let activeCommentListeners = []; // To detach comment listeners
    let allCommentsData = {}; // Global store for "All Comments" tab

    // DOM Elements
    const authContainer = document.getElementById("authContainer");
    const appContainer = document.getElementById("appContainer");
    const loginForm = document.getElementById("loginForm");
    const registerForm = document.getElementById("registerForm");
    const loginBtn = document.getElementById("loginBtn");
    const registerBtn = document.getElementById("registerBtn");
    const showRegister = document.getElementById("showRegister");
    const showLogin = document.getElementById("showLogin");
    const loginError = document.getElementById("loginError");
    const registerError = document.getElementById("registerError");
    
    const commentForm = document.getElementById("commentForm");
    const commentText = document.getElementById("commentText");
    const commentSubmitBtn = document.getElementById("commentSubmitBtn");
    const commentsContainer = document.getElementById("commentsContainer");
    const tabsContainer = document.getElementById("tabsContainer");
    const loadingElement = document.getElementById("loading");
    const authStatus = document.getElementById("authStatus");
    const logoutBtn = document.getElementById("logoutBtn");
    
    const notificationBell = document.getElementById("notificationBell");
    const notificationDot = document.getElementById("notificationDot");
    const notificationPanel = document.getElementById("notificationPanel");
    const notificationList = document.getElementById("notificationList");
    
    const whatsNewModal = document.getElementById("whatsNewModal");
    const closeModalBtn = document.getElementById("closeModalBtn");
    
    const sortOrderSelect = document.getElementById("sortOrder");

    // NEW: Post Modal Elements
    const postModal = document.getElementById("postModal");
    const postModalClose = document.getElementById("postModalClose");
    const postModalBody = document.getElementById("postModalBody");


    // ===== App Initialization =====
    
    // Check for "What's New" modal
    if (localStorage.getItem('seenWhatsNew_v1')) {
      whatsNewModal.style.display = 'none';
      authContainer.style.display = 'block'; // Show login
    } else {
      whatsNewModal.style.display = 'flex'; // Show modal
      authContainer.style.display = 'none'; // Hide login
    }

    closeModalBtn.addEventListener("click", () => {
      whatsNewModal.style.display = 'none';
      authContainer.style.display = 'block';
      localStorage.setItem('seenWhatsNew_v1', 'true');
    });

    // NEW: Post Modal Listeners
    postModalClose.addEventListener("click", () => {
      postModal.style.display = "none";
      postModalBody.innerHTML = ""; // Clear content
    });

    postModal.addEventListener("click", (e) => {
      if (e.target === postModal) { // Click on overlay
        postModal.style.display = "none";
        postModalBody.innerHTML = ""; // Clear content
      }
    });
    
    // Global click listener to close menus
    document.addEventListener('click', (e) => {
      // Close open menus
      document.querySelectorAll('.menu-dropdown').forEach(menu => {
        if (!menu.contains(e.target) && !menu.previousElementSibling.contains(e.target)) {
          menu.style.display = 'none';
        }
      });
      // Close notification panel
      if (!notificationBell.contains(e.target) && !notificationPanel.contains(e.target)) {
         notificationPanel.style.display = 'none';
      }
    });


    // Fetch all users for @mentions
    const usersRef = ref(db, 'users');
    onValue(usersRef, (snapshot) => {
      allUsers = snapshot.val() || {};
    });

    // ===== Authentication Logic =====

    // Toggle forms
    showRegister.addEventListener("click", () => {
      loginForm.style.display = "none";
      registerForm.style.display = "block";
      registerError.textContent = "";
      loginError.textContent = "";
    });
    showLogin.addEventListener("click", () => {
      registerForm.style.display = "none";
      loginForm.style.display = "block";
      registerError.textContent = "";
      loginError.textContent = "";
    });

    // Register
    registerBtn.addEventListener("click", () => {
      const username = document.getElementById("registerUsername").value.trim();
      const password = document.getElementById("registerPassword").value;
      
      registerError.textContent = "";
      if (!username || !password) {
        registerError.textContent = "Please enter a username and password.";
        return;
      }
      if (username.length < 3) {
         registerError.textContent = "Username must be at least 3 characters.";
         return;
      }
      if (username.includes("@") || username.includes(".")) {
         registerError.textContent = "Username cannot contain '@' or '.' symbols.";
         return;
      }

      const email = username + FAKE_EMAIL_DOMAIN;
      
      createUserWithEmailAndPassword(auth, email, password)
        .then((userCredential) => {
          // Set username in database
          const userRef = ref(db, 'users/' + userCredential.user.uid);
          set(userRef, { username: username })
            .then(() => {
              // Registration successful, auth state will handle login
            })
            .catch((dbError) => {
              registerError.textContent = "Error saving username: " + dbError.message;
            });
        })
        .catch((error) => {
          if (error.code === 'auth/email-already-in-use') {
            registerError.textContent = "This username is already taken.";
          } else if (error.code === 'auth/weak-password') {
            registerError.textContent = "Password is too weak. Must be 6+ characters.";
          } else {
            registerError.textContent = error.message;
          }
        });
    });

    // Login
    loginBtn.addEventListener("click", () => {
      const username = document.getElementById("loginUsername").value.trim();
      const password = document.getElementById("loginPassword").value;
      
      loginError.textContent = "";
      if (!username || !password) {
        loginError.textContent = "Please enter a username and password.";
        return;
      }
      
      const email = username + FAKE_EMAIL_DOMAIN;
      
      signInWithEmailAndPassword(auth, email, password)
        .then((userCredential) => {
          // Auth state will handle login
        })
        .catch((error) => {
           if (error.code === 'auth/invalid-credential' || error.code === 'auth/invalid-email' || error.code === 'auth/wrong-password') {
             loginError.textContent = "Invalid username or password.";
           } else {
             loginError.textContent = error.message;
           }
        });
    });

    // Logout
    logoutBtn.addEventListener("click", () => {
      signOut(auth);
    });

    // Auth State Change (Main app driver)
    onAuthStateChanged(auth, (user) => {
      // Detach all old notification listeners
      activeNotificationListeners.forEach(l => off(l.ref, l.type, l.func));
      activeNotificationListeners = [];
      notificationList.innerHTML = '<li class="no-notifications">No new notifications.</li>';
      notificationDot.style.display = 'none';

      // Detach all old comment listeners
      activeCommentListeners.forEach(l => off(l.ref, l.type, l.func));
      activeCommentListeners = [];
      allCommentsData = {};

      if (user) {
        // User is logged in
        authContainer.style.display = "none";
        appContainer.style.display = "block";
        
        // Get username from database
        const userRef = ref(db, 'users/' + user.uid);
        onValue(userRef, (snapshot) => {
          const userData = snapshot.val();
          if (userData && userData.username) {
            authUser = { uid: user.uid, username: userData.username };
            authStatus.textContent = `Logged in as: ${userData.username}`;
            commentForm.disabled = false;
            commentText.disabled = false;
            commentSubmitBtn.disabled = false;
            
            // Start loading comments and notifications
            loadComments();
            listenForNotifications(user.uid);
            
          } else {
            // This case might happen if DB write failed during signup
            authStatus.textContent = "Error: Username not found.";
            signOut(auth); // Log out to be safe
          }
        }, { onlyOnce: true });
        
      } else {
        // User is logged out
        authContainer.style.display = 'block';
        if (!localStorage.getItem('seenWhatsNew_v1')) {
          authContainer.style.display = 'none'; // Keep login hidden if modal is up
        }
        appContainer.style.display = 'none';
        
        // Clear old data
        authUser = null;
        commentsContainer.innerHTML = "<p>Please log in to see comments.</p>";
        authStatus.textContent = "You are not logged in.";
      }
    });

    // ===== Notification System =====
    
    function listenForNotifications(uid) {
      const notificationsRef = query(ref(db, `notifications/${uid}`), limitToLast(20));
      
      const onAdded = onChildAdded(notificationsRef, (snapshot) => {
        const notif = snapshot.val();
        if (!notif.read) {
          notificationDot.style.display = "block";
        }
        addNotificationToList(notif, snapshot.key); // Pass full notif object
      });

      const onRemoved = onChildRemoved(notificationsRef, (snapshot) => {
        const key = snapshot.key;
        const li = notificationList.querySelector(`li[data-key="${key}"]`);
        if (li) {
          li.remove();
        }
        if (notificationList.children.length === 0) {
            notificationList.innerHTML = '<li class="no-notifications">No new notifications.</li>';
        }
      });

      // Store listeners to detach on logout
      activeNotificationListeners = [
        { ref: notificationsRef, type: 'child_added', func: onAdded },
        { ref: notificationsRef, type: 'child_removed', func: onRemoved }
      ];
      
      // Check for unread on first load AND if list is empty
      onValue(notificationsRef, (snapshot) => {
         const notifs = snapshot.val();
         let hasUnread = false;
         let hasNotifs = false;
         if(notifs) {
           hasNotifs = true;
           Object.values(notifs).forEach(notif => {
             if (!notif.read) hasUnread = true;
           });
         }
         
         if (!hasUnread) {
           notificationDot.style.display = 'none';
         }
         
         if (!hasNotifs && notificationList.children.length === 0) {
            notificationList.innerHTML = '<li class="no-notifications">No new notifications.</li>';
         }
      }, { onlyOnce: true });
    }

    function addNotificationToList(notif, key) {
      const placeholder = notificationList.querySelector('.no-notifications');
      if (placeholder) placeholder.remove();
      
      const li = document.createElement("li");
      li.dataset.key = key;
      // NEW: Add timestamp
      li.innerHTML = `<span>${notif.message}</span><span class="notification-time">${getRelativeTime(notif.timestamp)}</span>`;
      
      // Add click listener to open modal
      if (notif.link) {
        li.dataset.linkPath = notif.link.path;
        li.dataset.linkType = notif.link.type;
        li.addEventListener("click", () => handleNotificationClick(notif.link));
      }
      
      notificationList.prepend(li);
    }
    
    notificationBell.addEventListener("click", (e) => {
      e.stopPropagation();
      const isOpen = notificationPanel.style.display === 'block';
      notificationPanel.style.display = isOpen ? 'none' : 'block';
      
      if (!isOpen) {
        // Mark all as read when opening
        notificationDot.style.display = 'none';
        const updates = {};
        notificationList.querySelectorAll('li').forEach(li => {
          if (li.dataset.key) {
            updates[`/notifications/${authUser.uid}/${li.dataset.key}/read`] = true;
          }
        });
        if (Object.keys(updates).length > 0) {
          update(ref(db), updates);
        }

        // Delete old notifications
        const cutoff = Date.now() - (15 * 24 * 60 * 60 * 1000); // 15 days ago
        const allNotifsRef = ref(db, `notifications/${authUser.uid}`);
        get(allNotifsRef).then((snapshot) => {
          if (snapshot.exists()) {
            snapshot.forEach((childSnapshot) => {
              if (childSnapshot.val().timestamp < cutoff) {
                remove(childSnapshot.ref);
              }
            });
          }
        }).catch((error) => {
           console.error("Error cleaning up notifications:", error);
        });
      }
    });

    // Handle clicking a notification
    async function handleNotificationClick(link) {
      if (!link || !link.path) return;

      postModalBody.innerHTML = ""; // Clear
      notificationPanel.style.display = 'none'; // Close panel
      postModal.style.display = 'flex'; // Show modal

      try {
        const snapshot = await get(ref(db, link.path));
        if (snapshot.exists()) {
          const commentData = snapshot.val();
          
          // Determine if it's a root comment
          const pathParts = link.path.split('/');
          const isRootComment = pathParts.length === 2 && pathParts[0] === 'comments';
          const category = isRootComment ? null : pathParts[1];
          
          // Need to create the element. We pass `true` for isModal to adjust paths.
          const commentElement = createCommentElement(
            { id: snapshot.key, ...commentData },
            category,
            isRootComment,
            null,
            false,
            true // isModal = true
          );
          postModalBody.appendChild(commentElement);
          
          // If the link was to a reply, find and scroll to it
          if (link.type === 'reply' && link.replyId) {
             const replyBox = commentElement.querySelector(`.reply-box[data-reply-id="${link.replyId}"]`);
             if (replyBox) {
               replyBox.style.backgroundColor = 'var(--reaction-highlight)';
               replyBox.scrollIntoView({ behavior: 'smooth', block: 'center' });
             }
          }

        } else {
          postModalBody.innerHTML = "<p>This post may have been deleted.</p>";
        }
      } catch (error) {
        console.error("Error fetching post:", error);
        postModalBody.innerHTML = "<p>Error loading post.</p>";
      }
    }
    
    async function sendNotification(targetUid, message, link = null) {
      if (!targetUid || targetUid === authUser.uid) return; // Don't notify self
      
      const notifRef = ref(db, `notifications/${targetUid}`);
      const newNotif = {
        message,
        timestamp: Date.now(),
        read: false,
        link // Add link object
      };
      await push(notifRef, newNotif);
    }

    // ===== Comment System =====

    // Handle new comment submission
    commentForm.addEventListener("submit", (e) => {
      e.preventDefault();
      const text = commentText.value.trim();
      if (!text || !authUser) return;

      const comment = {
        text,
        timestamp: Date.now(),
        userId: authUser.uid,
        username: authUser.username,
        replies: {}, // Use object
        reactions: {}, // Use object
      };
      
      const commentsRef = ref(db, `comments/${currentCategory}`);
      push(commentsRef, comment);
      commentText.value = "";
    });

    // Handle tab switching
    tabsContainer.addEventListener("click", (e) => {
      if (e.target.classList.contains("tab-btn")) {
        const newCategory = e.target.dataset.category;
        if (newCategory === currentCategory) return;

        tabsContainer.querySelector(".active").classList.remove("active");
        e.target.classList.add("active");
        currentCategory = newCategory;
        
        // Hide/show comment form
        if (currentCategory === 'all') {
          commentForm.style.display = 'none';
        } else {
          commentForm.style.display = 'block';
        }
        
        loadComments();
      }
    });
    
    // Handle sorting
    sortOrderSelect.addEventListener("change", (e) => {
      currentSortOrder = e.target.value;
      // Re-render
      displayComments(Object.values(allCommentsData));
    });

    // Load comments
    function loadComments() {
      commentsContainer.innerHTML = "";
      loadingElement.style.display = "block";
      
      // Detach all old listeners
      activeCommentListeners.forEach(l => off(l.ref, l.type, l.func));
      activeCommentListeners = [];
      allCommentsData = {}; // Clear data store

      if (currentCategory === 'all') {
        fetchAllCommentsLive();
      } else {
        fetchCategoryCommentsLive(currentCategory);
      }
    }

    // NEW: Live fetch for "All Comments"
    function fetchAllCommentsLive() {
      const categories = ['general', 'seniors', 'juniors', 'faculty'];
      
      // 1. Listen to all categories
      categories.forEach(category => {
        const commentsRef = ref(db, `comments/${category}`);
        const listener = onValue(commentsRef, (snapshot) => {
          loadingElement.style.display = 'none';
          const data = snapshot.val() || {};
          // Update global store
          Object.entries(data).forEach(([id, c]) => {
            allCommentsData[id] = { id, ...c, category: category, isRoot: false };
          });
          displayComments(Object.values(allCommentsData));
        });
        activeCommentListeners.push({ ref: commentsRef, type: 'value', func: listener });
      });
      
      // 2. Listen to root comments (old ones)
      const rootCommentsRef = ref(db, 'comments');
      const rootListener = onValue(rootCommentsRef, (snapshot) => {
          loadingElement.style.display = 'none';
          const data = snapshot.val() || {};
          Object.entries(data).forEach(([id, c]) => {
             // If the key is NOT a category, it's a root comment
             if (!categories.includes(id) && id !== 'users' && id !== 'notifications') {
                allCommentsData[id] = { id, ...c, category: null, isRoot: true };
             }
          });
          displayComments(Object.values(allCommentsData));
      });
      activeCommentListeners.push({ ref: rootCommentsRef, type: 'value', func: rootListener });
    }

    // NEW: Live fetch for single category
    function fetchCategoryCommentsLive(category) {
      const commentsRef = ref(db, `comments/${category}`);
      const listener = onValue(commentsRef, (snapshot) => {
        loadingElement.style.display = 'none';
        const data = snapshot.val() || {};
        allCommentsData = {}; // Clear store, we only care about this category
        Object.entries(data).forEach(([id, c]) => {
            allCommentsData[id] = { id, ...c, category: category, isRoot: false };
        });
        displayComments(Object.values(allCommentsData));
      }, (error) => {
          loadingElement.style.display = 'none';
          console.error("Permission denied loading category:", error);
          commentsContainer.innerHTML = `<p style='color: var(--tuntun-color);'>Error: Could not load ${category} comments.</p>`;
      });
      activeCommentListeners.push({ ref: commentsRef, type: 'value', func: listener });
    }
    
    function displayComments(comments) {
      commentsContainer.innerHTML = "";
      if (comments.length === 0) {
        commentsContainer.innerHTML = "<p>No comments yet. Be the first!</p>";
        return;
      }
      
      // Calculate reaction counts for sorting
      comments.forEach(c => {
        // NEW: Reaction count is just the number of keys
        c.reactionCount = Object.keys(c.reactions || {}).length;
      });
      
      // Separate pinned comments
      const pinned = comments.filter(c => c.isPinned);
      const unpinned = comments.filter(c => !c.isPinned);

      // Sort unpinned comments
      if (currentSortOrder === 'newest') {
        unpinned.sort((a, b) => b.timestamp - a.timestamp);
      } else if (currentSortOrder === 'popular') {
        unpinned.sort((a, b) => b.reactionCount - a.reactionCount);
      }
      
      // Pinned always come first
      const sortedComments = [...pinned, ...unpinned];

      sortedComments.forEach((c) => {
        const el = createCommentElement(c, c.category, c.isRoot);
        commentsContainer.appendChild(el);
      });
    }
    
    // Create a comment element
    function createCommentElement(comment, category, isRootComment, parentId = null, isReply = false, isModal = false) {
      const box = document.createElement("div");
      box.classList.add(isReply ? "reply-box" : "comment-box");
      if (comment.isPinned) box.classList.add('pinned-comment');
      if (isReply) box.dataset.replyId = comment.id; // For scrolling

      const header = document.createElement("div");
      header.classList.add("comment-header");

      const author = document.createElement("span");
      author.classList.add("comment-author");
      author.textContent = comment.username || 'Anonymous';
      if (comment.username?.toLowerCase() === 'admin') author.classList.add('admin');
      if (comment.username?.toLowerCase() === 'tuntun') author.classList.add('tuntun');
      header.appendChild(author);
      
      const time = document.createElement("span");
      time.classList.add("comment-time");
      time.textContent = `‚Ä¢ ${getRelativeTime(comment.timestamp)}`;
      header.appendChild(time);
      
      if (comment.isPinned) {
        const pinned = document.createElement("span");
        pinned.classList.add("pinned-badge");
        pinned.textContent = "üìå Pinned";
        header.appendChild(pinned);
      }

      box.appendChild(header);

      const text = document.createElement("p");
      text.classList.add(isReply ? "reply-text" : "comment-text");
      // Sanitize and highlight mentions
      text.innerHTML = sanitizeAndHighlightMentions(comment.text);
      box.appendChild(text);
      
      // ===== Comment Menu (Edit/Delete/Pin) =====
      const menu = document.createElement("div");
      menu.classList.add("comment-menu");
      
      const menuTrigger = document.createElement("button");
      menuTrigger.classList.add("menu-trigger-btn");
      menuTrigger.innerHTML = "&vellip;"; // ‚ãÆ
      
      const menuDropdown = document.createElement("div");
      menuDropdown.classList.add("menu-dropdown");
      
      menuTrigger.addEventListener("click", (e) => {
        e.stopPropagation();
        // Close all other menus
        document.querySelectorAll('.menu-dropdown').forEach(m => m.style.display = 'none');
        menuDropdown.style.display = menuDropdown.style.display === 'block' ? 'none' : 'block';
      });

      // Add actions based on permissions
      const isAdmin = authUser?.username?.toLowerCase() === 'admin';
      const isOwner = authUser?.uid === comment.userId;
      let hasMenu = false;

      // Pin button (Admin only, not on replies, not in modal)
      if (isAdmin && !isReply && !isModal) {
        hasMenu = true;
        const pinBtn = document.createElement("button");
        pinBtn.classList.add("pin-btn");
        pinBtn.textContent = comment.isPinned ? "üìå Unpin" : "üìå Pin";
        pinBtn.onclick = (e) => {
          e.stopPropagation();
          // Pinning only happens on main page, so paths are simple
          const commentPath = isRootComment 
            ? `comments/${comment.id}` 
            : `comments/${category}/${comment.id}`;
          const updates = { [`${commentPath}/isPinned`]: !comment.isPinned };
          update(ref(db), updates);
          menuDropdown.style.display = 'none';
        };
        menuDropdown.appendChild(pinBtn);
      }

      // Edit button (Owner only)
      if (isOwner) {
        hasMenu = true;
        const editBtn = document.createElement("button");
        editBtn.textContent = "‚úèÔ∏è Edit";
        editBtn.onclick = (e) => {
          e.stopPropagation();
          menuDropdown.style.display = 'none';
          showEditForm(box, text, comment, category, isRootComment, parentId, isReply, isModal);
        };
        menuDropdown.appendChild(editBtn);
      }
      
      // Delete button (Owner or Admin)
      if (isOwner || isAdmin) {
        hasMenu = true;
        const deleteBtn = document.createElement("button");
        deleteBtn.classList.add("delete-btn");
        deleteBtn.textContent = "üóëÔ∏è Delete";
        deleteBtn.onclick = (e) => {
          e.stopPropagation();
          if (deleteBtn.textContent === "üóëÔ∏è Delete") {
            deleteBtn.textContent = "Confirm?";
            // Reset after 3s
            setTimeout(() => {
                if (deleteBtn) deleteBtn.textContent = "üóëÔ∏è Delete";
            }, 3000);
          } else {
            let itemPath;
            // Get correct context (modal or main page)
            const itemCat = isModal ? category : comment.category;
            const itemRoot = isModal ? isRootComment : comment.isRoot;

            if (isReply) {
              const parentCat = isModal ? category : comment.parentCategory;
              const parentRoot = isModal ? isRootComment : comment.parentIsRoot;

              const replyParentPath = parentRoot
                ? `comments/${parentId}` 
                : `comments/${parentCat}/${parentId}`;
              itemPath = `${replyParentPath}/replies/${comment.id}`;
            } else {
              itemPath = itemRoot 
                ? `comments/${comment.id}` 
                : `comments/${itemCat}/${comment.id}`;
            }
            remove(ref(db, itemPath));
            if (isModal) {
              postModal.style.display = "none";
              postModalBody.innerHTML = "";
            }
          }
        };
        menuDropdown.appendChild(deleteBtn);
      }

      if (hasMenu) {
        menu.appendChild(menuTrigger);
        menu.appendChild(menuDropdown);
        header.appendChild(menu); // Add menu to header
      }

      // ===== Controls (Reply/Reactions) =====
      const controls = document.createElement("div");
      controls.classList.add("controls");
      
      const actionButtons = document.createElement("div");
      actionButtons.classList.add("action-buttons");

      let replyForm = null;
      // Add reply button (not on replies, not on 'all' tab unless in modal)
      if (!isReply && (currentCategory !== 'all' || isModal)) {
        const replyBtn = document.createElement("button");
        replyBtn.textContent = "üí¨ Reply";
        replyBtn.classList.add("reply-btn");
        actionButtons.appendChild(replyBtn);

        replyForm = document.createElement("form");
        replyForm.classList.add("reply-form");
        replyForm.style.display = "none";

        const replyInput = document.createElement("textarea");
        replyInput.placeholder = "Write a reply...";
        
        const mentionSuggestions = document.createElement('div');
        mentionSuggestions.classList.add('mention-suggestions');
        
        // Build list of users to mention
        const mentionableUsers = new Set();
        if(comment.username) mentionableUsers.add(comment.username);
        if(comment.replies) {
           Object.values(comment.replies).forEach(r => {
             if(r.username) mentionableUsers.add(r.username);
           });
        }
        mentionableUsers.delete(authUser.username); // Don't suggest self
        
        if (mentionableUsers.size > 0) {
          mentionSuggestions.innerHTML = '<span>Mention:</span>';
          mentionableUsers.forEach(username => {
            const mentionBtn = document.createElement('button');
            mentionBtn.type = 'button';
            mentionBtn.classList.add('mention-btn');
            mentionBtn.textContent = `@${username}`;
            mentionBtn.onclick = () => {
              replyInput.value += ` @${username} `;
              replyInput.focus();
            };
            mentionSuggestions.appendChild(mentionBtn);
          });
        }

        const replyButtons = document.createElement("div");
        replyButtons.classList.add("reply-form-buttons");

        const replyCancel = document.createElement("button");
        replyCancel.type = "button";
        replyCancel.textContent = "Cancel";
        replyCancel.classList.add("cancel-btn");
        replyCancel.onclick = () => { replyForm.style.display = "none"; };
        
        const replySubmit = document.createElement("button");
        replySubmit.type = "submit";
        replySubmit.textContent = "Post Reply";

        replyButtons.appendChild(replyCancel);
        replyButtons.appendChild(replySubmit);
        
        replyForm.appendChild(replyInput);
        replyForm.appendChild(mentionSuggestions);
        replyForm.appendChild(replyButtons);

        replyBtn.addEventListener("click", (e) => {
          if (e.target.classList.contains("reaction")) return;
          e.stopPropagation();
          const isOpen = replyForm.style.display === "block";
          // Close all forms in this box
          box.querySelectorAll('.reply-form, .edit-form').forEach(f => f.style.display = 'none');
          // Show text element in case edit was open
          box.querySelectorAll('.comment-text, .reply-text').forEach(t => t.style.display = 'block');
          
          if (!isOpen) {
            replyForm.style.display = "block";
            replyForm.querySelector('textarea').focus();
          }
        });

        replyForm.addEventListener("submit", (e) => {
          e.preventDefault();
          const replyText = replyInput.value.trim();
          if (!replyText || !authUser) return;
          
          const reply = {
            text: replyText,
            timestamp: Date.now(),
            userId: authUser.uid,
            username: authUser.username,
            reactions: {},
          };
          
          // Handle modal/main page pathing
          const itemCat = isModal ? category : comment.category;
          const itemRoot = isModal ? isRootComment : comment.isRoot;

          const replyPath = itemRoot 
            ? `comments/${comment.id}/replies`
            : `comments/${itemCat}/${comment.id}/replies`;
          
          const newReplyRef = push(ref(db, replyPath), reply);
          
          // --- Handle Reply Notifications ---
          // Link to the *top-level* comment, but note the reply ID
          const linkPath = itemRoot
            ? `comments/${comment.id}`
            : `comments/${itemCat}/${comment.id}`;
            
          const linkInfo = {
             path: linkPath,
             type: 'reply',
             replyId: newReplyRef.key
          };
          
          const mentionedUsers = extractMentions(replyText);
          if (mentionedUsers.size > 0) {
            // Notify mentioned users
            mentionedUsers.forEach(username => {
              const targetUser = Object.entries(allUsers).find(([uid, data]) => data.username === username);
              if (targetUser) {
                sendNotification(targetUser[0], `<strong>${authUser.username}</strong> mentioned you in a reply.`, linkInfo);
              }
            });
          } else {
            // Notify original commenter (if not self)
            if (comment.userId !== authUser.uid) {
              sendNotification(comment.userId, `<strong>${authUser.username}</strong> replied to your comment.`, linkInfo);
            }
          }
          
          replyInput.value = "";
          replyForm.style.display = "none";
        });
      }
      
      controls.appendChild(actionButtons);

      // ===== Reaction Controls (NEW LOGIC) =====
      const reactionContainer = document.createElement("div");
      reactionContainer.classList.add("reaction-options");
      
      // 1. Get counts for all emojis
      const reactionCounts = Object.values(comment.reactions || {}).reduce((acc, emoji) => {
        acc[emoji] = (acc[emoji] || 0) + 1;
        return acc;
      }, {});
      
      // 2. Get the current user's reaction
      const userReaction = comment.reactions?.[authUser.uid];

      reactions.forEach((emoji) => {
        const span = document.createElement("span");
        const count = reactionCounts[emoji] || 0;
        
        span.textContent = count > 0 ? `${emoji} ${count}` : emoji;
        span.classList.add("reaction");
        
        // 3. Highlight user's reaction
        if (userReaction === emoji) {
          span.classList.add("user-reacted");
        }

        span.addEventListener("click", (e) => {
          e.preventDefault();
          e.stopImmediatePropagation();
          
          let userReactionPath;
          let linkPath; // For notification
          let linkType = 'reaction';
          
          // Get correct context (modal or main page)
          // BUG FIX: isRoot was from comment, but on replies, need parent's context
          const parentCat = isModal ? category : comment.parentCategory;
          const parentRoot = isModal ? isRootComment : comment.parentIsRoot;

          const itemCat = isModal ? category : comment.category;
          const itemRoot = isModal ? isRootComment : comment.isRoot;
          
          if (isReply) {
             const replyParentPath = parentRoot
               ? `comments/${parentId}` 
               : `comments/${parentCat}/${parentId}`;
             userReactionPath = `${replyParentPath}/replies/${comment.id}/reactions/${authUser.uid}`;
             linkPath = replyParentPath; // Link to parent comment
             linkType = 'reply'; // Link to the parent comment, highlight reply
          } else {
             const commentPath = itemRoot 
               ? `comments/${comment.id}` 
               : `comments/${itemCat}/${comment.id}`;
             userReactionPath = `${commentPath}/reactions/${authUser.uid}`;
             linkPath = commentPath;
          }

          // 4. Set, change, or remove reaction
          const reactionRef = ref(db, userReactionPath);
          if (userReaction === emoji) {
            // User clicked their own reaction, remove it
            remove(reactionRef);
          } else {
            // User clicked a new or different reaction, set it
            set(reactionRef, emoji);
            
            // Send notification (but not for self, and only on new reaction)
            if(comment.userId !== authUser.uid && !userReaction) {
              const linkInfo = { 
                path: linkPath, 
                type: linkType,
                // if it's a reaction on a reply, add the replyId
                replyId: isReply ? comment.id : null 
              };
              sendNotification(comment.userId, `<strong>${authUser.username}</strong> reacted ${emoji} to your post.`, linkInfo);
            }
          }
        });

        reactionContainer.appendChild(span);
      });

      controls.appendChild(reactionContainer);
      box.appendChild(controls);
      if (replyForm) box.appendChild(replyForm);

      // ===== Render Replies =====
      if (comment.replies) {
        const repliesDiv = document.createElement("div");
        repliesDiv.classList.add("replies");
        
        // Get parent's context
        const parentCat = isModal ? category : comment.category;
        const parentRoot = isModal ? isRootComment : comment.isRoot;

        const sorted = Object.entries(comment.replies)
          .map(([id, r]) => ({ 
             id, 
             ...r, 
             // Pass down parent's category/root info for correct pathing
             parentCategory: parentCat,
             parentIsRoot: parentRoot
          }))
          .sort((a, b) => a.timestamp - b.timestamp);
        
        sorted.forEach((r) => {
          // Pass parent ID (comment.id)
          repliesDiv.appendChild(createCommentElement(r, null, null, comment.id, true, isModal));
        });
        box.appendChild(repliesDiv);
      }

      return box;
    }
    
    // Show edit form
    function showEditForm(box, textElement, comment, category, isRootComment, parentId, isReply, isModal) {
      textElement.style.display = 'none'; // Hide text
      // Close reply form if open
      const replyForm = box.querySelector('.reply-form');
      if (replyForm) replyForm.style.display = 'none';
      
      const editForm = document.createElement("form");
      editForm.classList.add("edit-form");
      
      const editInput = document.createElement("textarea");
      editInput.value = comment.text;
      
      const editButtons = document.createElement("div");
      editButtons.classList.add("edit-form-buttons");
      
      const cancelBtn = document.createElement("button");
      cancelBtn.type = "button";
      cancelBtn.textContent = "Cancel";
      cancelBtn.classList.add("cancel-btn");
      cancelBtn.onclick = () => {
        editForm.remove();
        textElement.style.display = 'block';
      };
      
      const saveBtn = document.createElement("button");
      saveBtn.type = "submit";
      saveBtn.textContent = "Save";
      
      editButtons.appendChild(cancelBtn);
      editButtons.appendChild(saveBtn);
      
      editForm.appendChild(editInput);
      editForm.appendChild(editButtons);
      
      box.insertBefore(editForm, textElement.nextSibling);
      editInput.focus();
      
      editForm.addEventListener("submit", (e) => {
        e.preventDefault();
        const newText = editInput.value.trim();
        if (!newText) return;
        
        let itemPath;
        // Get correct context (modal or main page)
        const parentCat = isModal ? category : comment.parentCategory;
        const parentRoot = isModal ? isRootComment : comment.parentIsRoot;

        const itemCat = isModal ? category : comment.category;
        const itemRoot = isModal ? isRootComment : comment.isRoot;

        if (isReply) {
          const replyParentPath = parentRoot
            ? `comments/${parentId}` 
            : `comments/${parentCat}/${parentId}`;
          itemPath = `${replyParentPath}/replies/${comment.id}`;
        } else {
          itemPath = itemRoot 
            ? `comments/${comment.id}` 
            : `comments/${itemCat}/${comment.id}`;
        }
        
        update(ref(db, itemPath), { text: newText });
        
        // No need to hide form, element will be re-rendered
      });
    }

    // ===== Utility Functions =====
    
    // Sanitize text for display
    function sanitize(text) {
      const el = document.createElement('div');
      el.textContent = text;
      return el.innerHTML;
    }
    
    // Find @mentions in text
    function extractMentions(text) {
      const mentionRegex = /@(\w+)/g;
      const matches = text.match(mentionRegex);
      if (!matches) return new Set();
      
      const allUsernames = Object.values(allUsers).map(u => u.username);
      
      // Get usernames from matches (e.g., '@admin' -> 'admin')
      // And filter to only include usernames that actually exist
      return new Set(
        matches.map(m => m.substring(1)).filter(u => allUsernames.includes(u))
      );
    }
    
    // Highlight @mentions in text
    function sanitizeAndHighlightMentions(text) {
      if (!text) return '';
      const allUsernames = Object.values(allUsers).map(u => u.username);
      
      // Regex to find @mentions, but only if they are valid users
      const mentionRegex = /@(\w+)/g;
      
      return sanitize(text).replace(mentionRegex, (match, username) => {
        if (allUsernames.includes(username)) {
          return `<span class="mention">@${username}</span>`;
        } else {
          return match; // Not a valid user, return original text
        }
      });
    }
    
    // Get relative time
    function getRelativeTime(timestamp) {
      const now = Date.now();
      const seconds = Math.floor((now - timestamp) / 1000);
      
      let interval = seconds / 31536000;
      if (interval > 1) return Math.floor(interval) + "y ago";
      interval = seconds / 2592000;
      if (interval > 1) return Math.floor(interval) + "mo ago";
      interval = seconds / 86400;
      if (interval > 1) return Math.floor(interval) + "d ago";
      interval = seconds / 3600;
      if (interval > 1) return Math.floor(interval) + "h ago";
      interval = seconds / 60;
      if (interval > 1) return Math.floor(interval) + "m ago";
      return Math.max(0, Math.floor(seconds)) + "s ago"; // Ensure it's not negative
    }

  </script>
</body>
</html>
